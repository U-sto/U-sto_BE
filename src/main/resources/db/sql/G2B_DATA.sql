use usto;
show tables;

-- 0) 로컬 파일 로드 허용 확인/설정
SHOW VARIABLES LIKE 'local_infile';
SET GLOBAL local_infile = 1;

-- 1) RAW 테이블 생성
DROP TABLE IF EXISTS TB_G2B_RAW;
CREATE TABLE TB_G2B_RAW (
  id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
  G2B_M_CO char(8),
  G2B_M_NM varchar(300),
  G2B_D_CO char(8),
  G2B_D_NM varchar(300),
  G2B_UPR DECIMAL(20,0),
  G2B_UPR_RAW VARCHAR(100)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 2) 적재
LOAD DATA LOCAL INFILE 'D:/g2b_list.csv'
INTO TABLE TB_G2B_RAW
CHARACTER SET utf8mb4
FIELDS TERMINATED BY '\t'
ENCLOSED BY '"'
LINES TERMINATED BY '\r\n'
IGNORE 1 ROWS
(G2B_M_CO, G2B_M_NM, G2B_D_CO, G2B_D_NM, @upr_raw)
SET
  G2B_UPR_RAW = @upr_raw, -- 일단 문자열로 가져오기
  G2B_UPR= -- 변환 로직
    CASE
      WHEN @upr_raw IS NULL OR TRIM(@upr_raw) = '' THEN NULL
      WHEN REPLACE(TRIM(@upr_raw), ',', '') REGEXP '^[0-9]+$'
        THEN CAST(REPLACE(TRIM(@upr_raw), ',', '') AS DECIMAL(20,0))
      ELSE NULL
    END; -- 데이터 중에서 일부 단가 데이터가 문제가 있어서 문자열로 먼저 가져오고, decimal로 변환을 거침
    
-- 3) 검증
SELECT COUNT(*) AS row_count 
FROM TB_G2B_RAW;

SELECT COUNT(DISTINCT G2B_D_CO)
FROM TB_G2B_RAW;

SELECT * 
FROM TB_G2B_RAW
WHERE G2B_D_CO = 24612653;

SELECT * 
FROM TB_G2B_RAW 
LIMIT 100;

-- TB_G2B001M

DROP TABLE IF EXISTS TB_G2B001M;
CREATE TABLE TB_G2B001M ( 
	G2B_M_CO CHAR(8) PRIMARY KEY COMMENT '물품분류코드', 
    G2B_M_NM VARCHAR(300) NOT NULL COMMENT '물품분류명', 
    CRE_BY VARCHAR(30) NOT NULL COMMENT '레코드 생성 주체', 
    CRE_AT DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '레코드 생성 시점', 
    UPD_BY VARCHAR(30) NULL COMMENT '마지막 레코드 업데이트 주체', 
    UPD_AT DATETIME NULL COMMENT '마지막 레코드 업데이트 시점'
)ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

INSERT INTO TB_G2B001M (
G2B_M_CO, 
G2B_M_NM, 
CRE_BY, 
CRE_AT)
SELECT DISTINCT
  G2B_M_CO,
  G2B_M_NM,
  'SYSTEM', -- 사용자가 아닌 시스템 작업의 CRE_BY는 SYSTME으로 통일한다.
  NOW()
FROM TB_G2B_RAW
WHERE G2B_M_CO IS NOT NULL;

SELECT COUNT(*) AS row_count FROM TB_G2B001M;
SELECT * FROM TB_G2B001M LIMIT 100;

-- TB_G2B001D

CREATE TABLE TB_G2B001D (
  G2B_D_CO CHAR(8) NOT NULL PRIMARY KEY COMMENT '물품식별코드',
  G2B_M_CO CHAR(8) NOT NULL COMMENT '물품분류코드 FK TB_G2B001M',
  G2B_D_NM VARCHAR(300) NOT NULL COMMENT '물품품목명',
  G2B_UPR DECIMAL(20,0) NOT NULL COMMENT '조달청 기준 계약단가(원)',
  CRE_BY VARCHAR(30) NOT NULL COMMENT '레코드 생성 주체(USER_ID 또는 SYSTEM)',
  CRE_AT DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '레코드 생성 시점',
  UPD_BY VARCHAR(30) NULL COMMENT '조달청 정보 마지막 업데이트 주체',
  UPD_AT DATETIME NULL COMMENT '조달청 정보 마지막 업데이트 시각',

  KEY IDX_TB_G2B001D_M (G2B_M_CO), -- MySQL이 자동으로 만들어주겠지만, 혹시 모르니 FK 선언시에 명시적으로 인덱스를 만들었다

  CONSTRAINT FK_TB_G2B001D_M
    FOREIGN KEY (G2B_M_CO)
    REFERENCES TB_G2B001M (G2B_M_CO)
    ON UPDATE CASCADE
    ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE INDEX IDX_RAW_DCO_UPR ON TB_G2B_RAW (G2B_D_CO, G2B_UPR); -- 오래 걸림

INSERT INTO TB_G2B001D (
  G2B_D_CO,
  G2B_M_CO,
  G2B_D_NM,
  G2B_UPR,
  CRE_BY,
  CRE_AT
)
SELECT
  G2B_D_CO,
  ANY_VALUE(G2B_M_CO),
  ANY_VALUE(G2B_D_NM),
  MAX(G2B_UPR),
  'SYSTEM',
  NOW()
FROM TB_G2B_RAW
WHERE G2B_D_CO IS NOT NULL
  AND G2B_M_CO IS NOT NULL
  AND G2B_UPR IS NOT NULL   -- 비정상적인 단가 정보 필터링
GROUP BY G2B_D_CO;

SELECT COUNT(*) AS row_count FROM TB_G2B001D;
SELECT * FROM TB_G2B001D LIMIT 100;








